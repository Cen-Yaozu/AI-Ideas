# AI SDK 快速上手指南 🚀

> **目标**: 15分钟内从零到构建第一个AI应用
> **适合人群**: 有基础JavaScript/TypeScript经验的前端开发者
> **难度**: ⭐⭐☆☆☆ (初级)

---

## 🎯 准备工作

### 环境要求
- Node.js 18+
- 基础的React/Next.js知识
- 任何AI提供商的API Key（推荐OpenAI）

### 准备API Key
1. **OpenAI**: https://platform.openai.com/api-keys
2. **Anthropic**: https://console.anthropic.com/
3. **Google AI**: https://makersuite.google.com/app/apikey

---

## ⚡ 快速开始（3分钟）

### 1. 创建项目
```bash
# 创建Next.js项目（推荐）
npx create-next-app@latest my-ai-app --typescript
cd my-ai-app

# 或创建基础React项目
npx create-react-app my-ai-app --template typescript
cd my-ai-app
```

### 2. 安装依赖
```bash
# 基础依赖
npm install ai @ai-sdk/react @ai-sdk/openai

# 如果需要MCP工具支持，还需安装：
npm install @modelcontextprotocol/sdk zod
```

### 3. 配置环境变量
```bash
# 创建.env.local文件
echo "OPENAI_API_KEY=your_actual_key_here" > .env.local
```

---

## 🎪 第一个AI功能：文本生成（5分钟）

### 基础文本生成
```tsx
// app/page.tsx (Next.js) 或 src/App.tsx (React)
import { useState } from 'react';
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';

export default function Home() {
  const [prompt, setPrompt] = useState('');
  const [result, setResult] = useState('');
  const [loading, setLoading] = useState(false);

  const generateAnswer = async () => {
    setLoading(true);
    try {
      const { text } = await generateText({
        model: openai('gpt-4o-mini'),
        prompt: prompt,
        maxTokens: 200,
      });
      setResult(text);
    } catch (error) {
      setResult('出错了：' + error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h1>AI 文本生成器</h1>
      <textarea
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        placeholder="输入你的问题..."
        style={{ width: '100%', height: '100px', marginBottom: '10px' }}
      />
      <button onClick={generateAnswer} disabled={loading || !prompt}>
        {loading ? '生成中...' : '生成回答'}
      </button>
      {result && (
        <div style={{
          marginTop: '20px',
          padding: '15px',
          backgroundColor: '#f5f5f5',
          borderRadius: '8px'
        }}>
          <h3>AI回答：</h3>
          <p>{result}</p>
        </div>
      )}
    </div>
  );
}
```

运行项目：
```bash
npm run dev
```
访问 http://localhost:3000，你就有了一个能工作的AI文本生成器！

---

## 💬 升级功能：聊天机器人（7分钟）

### 使用AI SDK的useChat hook
```tsx
// app/chat/page.tsx
'use client';

import { useChat } from '@ai-sdk/react';
import { Button } from '@/components/ui/button'; // 可选：使用shadcn/ui

export default function ChatPage() {
  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat({
    api: '/api/chat', // 创建这个API端点
  });

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100vh' }}>
      <div style={{ flex: 1, overflow: 'auto', padding: '20px' }}>
        {messages.map(message => (
          <div
            key={message.id}
            style={{
              marginBottom: '15px',
              display: 'flex',
              justifyContent: message.role === 'user' ? 'flex-end' : 'flex-start'
            }}
          >
            <div
              style={{
                maxWidth: '70%',
                padding: '10px 15px',
                borderRadius: '18px',
                backgroundColor: message.role === 'user' ? '#007bff' : '#f1f3f4',
                color: message.role === 'user' ? 'white' : 'black'
              }}
            >
              {message.content}
            </div>
          </div>
        ))}
        {isLoading && (
          <div style={{ padding: '10px', color: '#666' }}>
            AI正在思考...
          </div>
        )}
      </div>

      <form onSubmit={handleSubmit} style={{ padding: '20px', borderTop: '1px solid #eee' }}>
        <div style={{ display: 'flex', gap: '10px' }}>
          <input
            value={input}
            onChange={handleInputChange}
            placeholder="输入消息..."
            style={{
              flex: 1,
              padding: '12px',
              border: '1px solid #ddd',
              borderRadius: '24px',
              outline: 'none'
            }}
            disabled={isLoading}
          />
          <button
            type="submit"
            disabled={isLoading || !input}
            style={{
              padding: '12px 20px',
              backgroundColor: '#007bff',
              color: 'white',
              border: 'none',
              borderRadius: '24px',
              cursor: 'pointer'
            }}
          >
            发送
          </button>
        </div>
      </form>
    </div>
  );
}
```

### 创建API端点
```ts
// app/api/chat/route.ts
import { openai } from '@ai-sdk/openai';
import { streamText } from 'ai';

export async function POST(req: Request) {
  const { messages } = await req.json();

  const result = await streamText({
    model: openai('gpt-4o-mini'),
    messages,
  });

  return result.toDataStreamResponse();
}
```

---

## 🛠️ 进阶功能：结构化数据生成（10分钟）

### 智能表单填充
```tsx
// app/form/page.tsx
'use client';

import { useState } from 'react';
import { generateObject } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

export default function SmartForm() {
  const [userInput, setUserInput] = useState('');
  const [formData, setFormData] = useState(null);
  const [loading, setLoading] = useState(false);

  const extractInfo = async () => {
    setLoading(true);
    try {
      const { object } = await generateObject({
        model: openai('gpt-4o-mini'),
        prompt: `从以下文本中提取个人信息：${userInput}`,
        schema: z.object({
          name: z.string().describe('姓名'),
          email: z.string().email().describe('邮箱地址'),
          age: z.number().optional().describe('年龄'),
          phone: z.string().optional().describe('电话号码'),
          interests: z.array(z.string()).describe('兴趣爱好'),
        }),
      });
      setFormData(object);
    } catch (error) {
      alert('提取失败：' + error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h1>智能信息提取</h1>

      <div style={{ marginBottom: '20px' }}>
        <h3>输入一段包含个人信息的话：</h3>
        <textarea
          value={userInput}
          onChange={(e) => setUserInput(e.target.value)}
          placeholder="例如：我是张三，25岁，邮箱是zhangsan@email.com，喜欢编程和旅游"
          style={{ width: '100%', height: '100px', marginTop: '10px' }}
        />
        <button
          onClick={extractInfo}
          disabled={loading || !userInput}
          style={{ marginTop: '10px', padding: '10px 20px' }}
        >
          {loading ? '提取中...' : '提取信息'}
        </button>
      </div>

      {formData && (
        <div style={{
          padding: '20px',
          backgroundColor: '#f8f9fa',
          borderRadius: '8px'
        }}>
          <h3>提取结果：</h3>
          <div style={{ display: 'grid', gap: '10px' }}>
            <div><strong>姓名：</strong> {formData.name}</div>
            <div><strong>邮箱：</strong> {formData.email}</div>
            {formData.age && <div><strong>年龄：</strong> {formData.age}</div>}
            {formData.phone && <div><strong>电话：</strong> {formData.phone}</div>
            {formData.interests.length > 0 && (
              <div><strong>兴趣：</strong> {formData.interests.join(', ')}</div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
```

---

## 🎨 高级功能：AI工具调用（12分钟）

### 给AI添加"超能力" - 让AI调用外部工具
```tsx
// app/weather/page.tsx
'use client';

import { useState } from 'react';
import { generateText, tool } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

// 模拟的工具函数
const weatherTool = tool({
  description: '获取指定城市的天气信息',
  parameters: z.object({
    city: z.string().describe('城市名称'),
  }),
  execute: async ({ city }) => {
    // 模拟天气API调用
    const weatherData = {
      '北京': { temp: 25, condition: '晴天', humidity: 40 },
      '上海': { temp: 22, condition: '多云', humidity: 65 },
      '广州': { temp: 28, condition: '小雨', humidity: 80 },
    };

    const weather = weatherData[city] || { temp: 20, condition: '未知', humidity: 50 };

    return {
      city,
      temperature: weather.temp,
      condition: weather.condition,
      humidity: weather.humidity,
    };
  },
});

const timeTool = tool({
  description: '获取当前时间',
  parameters: z.object({}).optional(),
  execute: async () => {
    return {
      currentTime: new Date().toLocaleString('zh-CN'),
      timestamp: Date.now(),
    };
  },
});

export default function WeatherAssistant() {
  const [query, setQuery] = useState('');
  const [response, setResponse] = useState('');
  const [loading, setLoading] = useState(false);
  const [toolCalls, setToolCalls] = useState([]);

  const askAI = async () => {
    setLoading(true);
    setToolCalls([]);

    try {
      const { text, toolCalls } = await generateText({
        model: openai('gpt-4o-mini'),
        prompt: query,
        tools: {
          getWeather: weatherTool,
          getCurrentTime: timeTool,
        },
      });

      setResponse(text);
      setToolCalls(toolCalls.map(call => ({
        name: call.toolName,
        args: call.args,
        result: call.result,
      })));
    } catch (error) {
      setResponse('出错：' + error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{ padding: '20px', maxWidth: '800px', margin: '0 auto' }}>
      <h1>🤖 AI助手（带工具）</h1>
      <p>可以查询天气、时间等信息</p>

      <div style={{ marginBottom: '20px' }}>
        <textarea
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="试试问：北京天气怎么样？现在几点了？"
          style={{ width: '100%', height: '80px' }}
        />
        <button
          onClick={askAI}
          disabled={loading || !query}
          style={{ marginTop: '10px', padding: '10px 20px' }}
        >
          {loading ? '思考中...' : '提问'}
        </button>
      </div>

      {toolCalls.length > 0 && (
        <div style={{ marginBottom: '20px' }}>
          <h3>🔧 工具调用记录：</h3>
          {toolCalls.map((call, index) => (
            <div key={index} style={{
              backgroundColor: '#f0f8ff',
              padding: '10px',
              marginBottom: '10px',
              borderRadius: '5px',
              fontSize: '14px'
            }}>
              <strong>工具：</strong> {call.name} |
              <strong> 参数：</strong> {JSON.stringify(call.args)} |
              <strong> 结果：</strong> {JSON.stringify(call.result)}
            </div>
          ))}
        </div>
      )}

      {response && (
        <div style={{
          padding: '15px',
          backgroundColor: '#f5f5f5',
          borderRadius: '8px'
        }}>
          <h3>AI回答：</h3>
          <p>{response}</p>
        </div>
      )}
    </div>
  );
}
```

---

---

## 🎪 进阶功能：MCP工具集成（15分钟）

### MCP（Model Context Protocol）是什么？

MCP 是一个标准化的协议，让AI模型能够安全地访问外部工具和数据源。**AI SDK 已经内置支持！**

### 快速开始MCP工具

#### 1. 安装额外依赖
```bash
# MCP支持需要额外的包
npm install @modelcontextprotocol/sdk zod
```

#### 2. 创建简单的MCP服务器
```ts
// mcp-server.ts - 简单的MCP服务器
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';

const server = new McpServer({
  name: 'pokemon-tools',
  version: '1.0.0',
});

// 添加工具
server.tool(
  'get-pokemon',
  '获取宝可梦信息',
  {
    name: z.string().describe('宝可梦名称'),
  },
  async ({ name }) => {
    // 模拟API调用
    return {
      content: [
        {
          type: 'text',
          text: `找到了宝可梦 ${name}！`,
        },
      ],
    };
  },
);

// 启动服务器
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.log('MCP 服务器已启动');
}

main().catch(console.error);
```

#### 3. 在AI应用中使用MCP工具
```tsx
// app/page.tsx
'use client';

import { useState } from 'react';
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';
import { experimental_createMCPClient } from '@ai-sdk/mcp';
import { Experimental_StdioMCPTransport } from '@ai-sdk/mcp';
import { z } from 'zod';

export default function MCPDemo() {
  const [prompt, setPrompt] = useState('');
  const [result, setResult] = useState('');
  const [loading, setLoading] = useState(false);

  const callAI = async () => {
    setLoading(true);

    try {
      // 创建MCP客户端连接到本地服务器
      const mcpClient = await experimental_createMCPClient({
        transport: new Experimental_StdioMCPTransport({
          command: 'node',
          args: ['mcp-server.ts'],
        }),
      });

      // 获取MCP工具
      const tools = await mcpClient.tools({
        schemas: {
          'get-pokemon': {
            inputSchema: z.object({
              name: z.string().describe('要查询的宝可梦名称'),
            }),
          },
        },
      });

      // 使用工具调用AI模型
      const { text } = await generateText({
        model: openai('gpt-4o-mini'),
        prompt: prompt,
        tools,
      });

      setResult(text);

      // 关闭客户端
      await mcpClient.close();
    } catch (error) {
      setResult('错误: ' + error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h1>🔧 MCP 工具演示</h1>
      <p>查询宝可梦信息</p>

      <textarea
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        placeholder="例如：帮我找一下皮卡丘的信息"
        style={{
          width: '100%',
          height: '80px',
          marginBottom: '10px',
          padding: '10px',
          border: '1px solid #ddd',
          borderRadius: '4px'
        }}
      />

      <button
        onClick={callAI}
        disabled={loading || !prompt}
        style={{
          padding: '10px 20px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer'
        }}
      >
        {loading ? '查询中...' : '查询'}
      </button>

      {result && (
        <div style={{
          marginTop: '20px',
          padding: '15px',
          backgroundColor: '#f8f9fa',
          borderRadius: '8px',
          border: '1px solid #e9ecef'
        }}>
          <h3>🎯 查询结果：</h3>
          <p>{result}</p>
        </div>
      )}
    </div>
  );
}
```

#### 4. 高级MCP用法：HTTP传输
```tsx
// 连接到远程MCP服务器
import { experimental_createMCPClient } from '@ai-sdk/mcp';
import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp';

const mcpClient = await experimental_createMCPClient({
  transport: new StreamableHTTPClientTransport(
    new URL('https://your-mcp-server.com/mcp'), {
      sessionId: 'my-session',
    }
  ),
});

// 使用工具
const tools = await mcpClient.tools();
const { text } = await generateText({
  model: openai('gpt-4o'),
  tools,
  prompt: '使用可用的工具帮我处理数据',
});
```

### MCP工具的优势

✅ **标准化接口** - 一次编写，多处使用
✅ **类型安全** - 完整的TypeScript支持
✅ **实时更新** - 工具变更自动同步
✅ **多传输支持** - HTTP、SSE、STDIO
✅ **灵活配置** - 支持OAuth、自定义头部

### MCP vs 普通工具调用

| 特性 | 普通工具调用 | MCP工具 |
|------|-------------|----------|
| **工具发现** | 手动定义 | 自动发现 |
| **版本管理** | 需要手动更新 | 自动同步 |
| **标准化** | 各自定义 | MCP标准 |
| **多服务器** | 复杂集成 | 简单配置 |
| **实时性** | 需要轮询 | 事件驱动 |

---

## 🎯 实用模板库

### 1. 简单文本补全
```tsx
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';

const SimpleCompletion = ({ prompt }: { prompt: string }) => {
  const [result, setResult] = useState('');

  useEffect(() => {
    const generate = async () => {
      const { text } = await generateText({
        model: openai('gpt-4o-mini'),
        prompt: `请简洁回答：${prompt}`,
        maxTokens: 100,
      });
      setResult(text);
    };
    generate();
  }, [prompt]);

  return <div>{result}</div>;
};
```

### 2. 流式文本生成
```tsx
import { streamText } from 'ai';
import { openai } from '@ai-sdk/openai';

const StreamingCompletion = () => {
  const [text, setText] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);

  const startStream = async (prompt: string) => {
    setIsStreaming(true);
    setText('');

    const { textStream } = await streamText({
      model: openai('gpt-4o-mini'),
      prompt,
    });

    for await (const textPart of textStream) {
      setText(prev => prev + textPart);
    }
    setIsStreaming(false);
  };

  return (
    <div>
      <div style={{ minHeight: '100px', border: '1px solid #ddd', padding: '10px' }}>
        {text || (isStreaming ? '正在生成...' : '等待输入')}
      </div>
      <button onClick={() => startStream('讲一个有趣的故事')}>
        开始生成故事
      </button>
    </div>
  );
};
```

### 3. 智能文档总结
```tsx
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';

const DocumentSummarizer = () => {
  const [document, setDocument] = useState('');
  const [summary, setSummary] = useState('');
  const [loading, setLoading] = useState(false);

  const summarize = async () => {
    if (!document.trim()) return;

    setLoading(true);
    try {
      const { text } = await generateText({
        model: openai('gpt-4o-mini'),
        prompt: `请为以下文档生成简洁的总结（200字以内）：\n\n${document}`,
        maxTokens: 300,
      });
      setSummary(text);
    } catch (error) {
      setSummary('总结失败：' + error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <textarea
        value={document}
        onChange={(e) => setDocument(e.target.value)}
        placeholder="粘贴需要总结的文档内容..."
        style={{ width: '100%', height: '200px' }}
      />
      <button onClick={summarize} disabled={loading || !document}>
        {loading ? '总结中...' : '生成总结'}
      </button>
      {summary && (
        <div style={{
          marginTop: '20px',
          padding: '15px',
          backgroundColor: '#e8f5e8',
          borderRadius: '8px'
        }}>
          <h3>📄 文档总结：</h3>
          <p>{summary}</p>
        </div>
      )}
    </div>
  );
};
```

---

## 💡 快速部署

### 1. Vercel部署（推荐）
```bash
# 安装Vercel CLI
npm i -g vercel

# 部署
vercel

# 设置环境变量
vercel env add OPENAI_API_KEY
```

### 2. 其他平台
```bash
# 构建项目
npm run build

# 部署到不同平台
# Netlify: npm run deploy 或拖拽构建文件夹到Netlify
# Railway: 连接GitHub仓库自动部署
# Cloudflare Pages: 连接GitHub仓库
```

---

## ⚠️ 常见问题解决

### 1. API Key错误
```javascript
// 检查API Key是否正确设置
console.log('API Key存在:', !!process.env.OPENAI_API_KEY);

// 或者在代码中直接检查
if (!process.env.OPENAI_API_KEY) {
  throw new Error('请设置 OPENAI_API_KEY 环境变量');
}
```

### 2. 网络问题
```typescript
// 添加重试机制
const generateWithRetry = async (prompt: string, maxRetries = 3) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const { text } = await generateText({
        model: openai('gpt-4o-mini'),
        prompt,
      });
      return text;
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      console.log(`重试第${i + 1}次...`);
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
};
```

### 3. Token限制
```typescript
// 自动截断长文本
const truncateText = (text: string, maxTokens: number = 3000) => {
  // 粗略估算：1个Token约等于4个字符
  const maxChars = maxTokens * 4;
  return text.length > maxChars ? text.slice(0, maxChars) + '...' : text;
};
```

---

## 🚀 下一步学习

### 1. 高级功能
- **多模态**: 图像输入和生成
- **流式UI**: 动态生成用户界面
- **RAG**: 检索增强生成
- **Agent**: 自主AI代理

### 2. 生产优化
- **缓存策略**: 减少API调用成本
- **错误处理**: 完善的错误处理和重试
- **监控**: AI调用成本和性能监控
- **安全**: 内容过滤和用户权限控制

### 3. 生态集成
- **Vercel AI Gateway**: 流量管理和监控
- **LangChain**: 复杂工作流集成
- **向量数据库**: RAG和语义搜索

---

## 📚 有用资源

### 官方资源
- **AI SDK文档**: https://ai-sdk.dev/docs
- **Playground**: https://ai-sdk.dev/playground
- **Cookbook**: https://ai-sdk.dev/docs/cookbook
- **GitHub**: https://github.com/vercel/ai

### 社区资源
- **Discord社区**: 与其他开发者交流
- **GitHub Discussions**: 技术问题讨论
- **YouTube教程**: 实战演示视频

### 模板项目
- **Chatbot模板**: https://github.com/vercel/ai-chatbot
- **RAG示例**: https://github.com/vercel/ai-rag-chatbot
- **多模态**: https://github.com/vercel/ai-multimodal-chatbot

---

## 🎯 总结

通过这个快速上手指南，你应该已经能够：

✅ **10分钟内搭建第一个AI应用**
✅ **掌握基础的文本生成和聊天功能**
✅ **理解工具调用的概念和用法**
✅ **了解常见的部署方式**

### 关键要点
1. **从简单开始**: 先用`generateText`，再学习`useChat`
2. **错误处理**: 始终包含try-catch和loading状态
3. **成本控制**: 使用gpt-4o-mini进行开发，gpt-4o用于生产
4. **用户体验**: 添加loading状态和错误提示
5. **安全性**: 不要在前端暴露API Key

### 下一步
尝试修改示例代码，创建你自己的AI应用！AI SDK的强大之处在于它让复杂的AI功能变得简单易用。

---

🎉 **恭喜！你已经掌握了AI SDK的基础用法，可以开始构建自己的AI应用了！**

---

*教程版本: AI SDK v5.0+*
*最后更新: 2025-10-27*